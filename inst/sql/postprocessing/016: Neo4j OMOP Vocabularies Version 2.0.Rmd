---
title: "016: Neo4j OMOP Vocabularies Version 2.0"
output: 
  html_document:
    css: style.css
    theme: flatly
    highlight: kate  
    toc: yes
    number_sections: false
    toc_depth: 3 
    # toc_float: 
      # collapsed: false  
      # smooth_scroll: false
    code_folding: show #or hide
    df_print: paged
    fig_height: 5 
    fig_width: 7 
    fig_caption: true
    dev: png
params: 
  # Process Control. If any are set to TRUE, all 
  # following values must be TRUE  
  rewrite_base_tables:      FALSE  
  rewrite_node_edge_tables: TRUE
  rewrite_csvs:             TRUE  
  import_to_neo4j:          TRUE 
  load_into_neo4j:          FALSE  
  # Neo4j Params  
  neo4j_db:  dbms-a43273b3-3fe5-4003-9bbc-511e24d262cc      
  dbmss_path: ~/Library/Application Support/com.Neo4j.Relate/Data/dbmss 
  label_col: domain_id
  id_col:    concept_id  
  name_col:  concept_name 
knit: (function(inputFile, encoding) {
  rmarkdown::render(inputFile,
                    encoding = encoding,
                    output_dir =
                      file.path(getwd(), "output"))
  })
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  comment = "##",
  tidy = FALSE, #`styler` to use styler:style_text() to reformat code
  tidy.opts = list(blank = FALSE, width.cutoff = 60),
  echo = TRUE,
  eval = TRUE,
  cache = FALSE,
  cache.path = file.path(dirname(getwd()), "cache", sub("_cache/.*$", "", knitr::opts_chunk$get("cache.path")), "/"),
  child = NULL, #file/s to knit and then include,
  collapse = FALSE, #collapse all output into a single block,
  error = FALSE, #display error messages in doc. FALSE stops render when error is thrown
  fig.align = "center", #left, right, center, or default
  fig.width = 7, #inches
  fig.height = 7, #inches
  fig.asp=0.50, #adds whitespace around images
  include = TRUE, #include chunk?
  message = FALSE, #display code messages?
  warning = FALSE, #include warnings?
  results = "markup"
    # "asis": passthrough results
    # "hide": do not display results 
    # "hold": put all results below all code
)  

issue_key    <- "016"  
report_title <- "Neo4j OMOP Vocabularies Version 2.0"  
version      <- "2.0"
rmd_title    <- basename(knitr::opts_chunk$get("cache.path"))
github_page  <- sprintf("https://redesigned-parakeet-dd0fdc07.pages.github.io/output/%s.html", rmd_title)
source_code  <- sprintf("https://github.com/PiriHealth/medportal-review/blob/main/rmd/%s.Rmd", rmd_title)
```

```{r,echo=FALSE,results='asis'}
import_folder <- 
  file.path(params$dbmss_path,
            params$neo4j_db, 
            "import")

if (!dir.exists(import_folder)) { 
  cat("# Error  \n")
  cat(sprintf("`%s` does not exist. Setup not performed.  \n", params$neo4j_db)) 
  knitr::knit_exit()
} 

database_data_folder <- 
  file.path(params$dbmss_path,
            params$neo4j_db,
            "data",
            "databases")

if (length(list.files(database_data_folder)) != 0) {
  cat(sprintf("**Note**: `%s` has already been instantiated and neo4j-admin import can only be called on a fresh database. All code chunks will not be evaluated. \n", params$neo4j_db)) 
  
  knitr::opts_chunk$set(
    eval = FALSE
  )
}
```


**Last Updated On:** `r Sys.time()`  
**GitHub Page:** `r github_page`  
**Source Code:** `r source_code` 

```{r setup2,eval=TRUE,message=FALSE,echo=FALSE}
library(tidyverse)
library(chariot)
project_path <- "~/GitHub/projects/medportal-review"
project_path <- path.expand(project_path)
```


```{r folders,eval=TRUE,echo=FALSE,results='hide',message=FALSE}
global_data_folder  <- file.path(project_path, "data", issue_key, report_title)
raw_folder          <- file.path(global_data_folder, "raw")
intermediate_folder <- file.path(global_data_folder, "intermediate")
final_folder        <- file.path(global_data_folder, "final")
outgoing_folder     <- file.path(global_data_folder, "outgoing") 


global_rmd_folder   <- file.path(project_path, "rmd", issue_key)
child_rmd_folder    <- file.path(global_rmd_folder, report_title)

global_img_folder   <- file.path(project_path, "img", issue_key)
img_folder          <- file.path(global_img_folder, report_title)

pre_data_folder   <- file.path(final_folder, "pre")
cache_folder      <- file.path(project_path, "cache", issue_key, report_title, "/")
sapply(c(global_data_folder,
         raw_folder,
         intermediate_folder,
         final_folder,
         outgoing_folder,
         global_rmd_folder,
         child_rmd_folder,
         global_img_folder,
         img_folder, 
         pre_data_folder,
         cache_folder),
       create_path)
```

# Parameters  

```{r omop_version,echo=FALSE,results='hide'}
omop_version <- 
  pg13::query(
    conn_fun = "pg13::local_connect()",
    sql_statement = "SELECT sa_release_version FROM public.setup_athena_log WHERE sa_datetime IN (SELECT MAX(sa_datetime) FROM public.setup_athena_log);") %>%
  mutate_all(as.character) %>%
  unlist() %>%
  unname()
```

## Process Control   

### Parameterized Settings  

```{r,echo=FALSE}
print_input(`Rewrite Base Tables?`           = params$rewrite_base_tables,
            `Rewrite Node and Edge Tables?`  = params$rewrite_node_edge_tables,
            `Rewrite Node and Edge CSVS?`    = params$rewrite_csvs,
            `Import to Neo4j Import Folder?` = params$import_to_neo4j,
            `Load Data into Neo4j?`          = params$load_into_neo4j)
```


### Updated Settings  

By definition, all subsequent steps must be TRUE. 

```{r}
parameterized_settings <- 
     c(`Rewrite Base Tables?`           = params$rewrite_base_tables,
       `Rewrite Node and Edge Tables?`  = params$rewrite_node_edge_tables,
       `Rewrite Node and Edge CSVS?`    = params$rewrite_csvs,
       `Import to Neo4j Import Folder?` = params$import_to_neo4j,
       `Load Data into Neo4j?`          = params$load_into_neo4j)


updated_settings <- parameterized_settings

if (any(parameterized_settings == TRUE)) {
  
  i <- 0
  for (parameterized_setting in parameterized_settings) {
    
    i <- i+1 
    
    if (parameterized_setting == TRUE) {
      first_true_index <- i
      break
    }
  }
  
  for (i in first_true_index:length(updated_settings)) {
    
    updated_settings[i] <- TRUE
    
  }
}

updated_settings <- 
  as.list(updated_settings)
  

print_input(`Rewrite Base Tables?`           = updated_settings$`Rewrite Base Tables?`,
            `Rewrite Node and Edge Tables?`  = updated_settings$`Rewrite Node and Edge Tables?`,
            `Rewrite Node and Edge CSVS?`    = updated_settings$`Rewrite Node and Edge CSVS?`,
            `Import to Neo4j Import Folder?` = updated_settings$`Import to Neo4j Import Folder?`,
            `Load Data into Neo4j?`          = updated_settings$`Load Data into Neo4j?`)
```

```{r,echo=FALSE,results='asis'}
if (all(updated_settings == FALSE)) {
  cat("Note that no writing, import, and load operations will occur in this run.  ",
      sep = "\n")
}
```


## Neo4j  

```{r input,echo=FALSE}
print_input(`Database ID`   = params$neo4j_db,
            `:LABEL`        = params$label_col,
            `:ID`           = params$id_col, 
             Name           = params$name_col,
            `Vocab Version` = omop_version)
```

# Changelog    

* [Issue I](#issue-i): To incorporate `vocabulary_name` field 
in the Vocabulary table as a node property, a forced double-quote 
protection had to be enforced since the presence of commas in 
some of the values was throwing off how the CSV data was being 
imported into Neo4j.  

* [Issue II](#issue-ii): Any mappings to itself are removed 
from the edges table because the hold on semantic value for the 
use case.  

* [Issue III](#issue-iii): A link to the Athena page is added to 
the node properties.  


# Table Setup   

## Base Tables in OMOP Vocabulary Schema  

If a new OMOP Version is detected based on the log, 
new Edge and Node tables are written.  

```sql
DROP TABLE IF EXISTS omop_vocabulary.edge;
CREATE TABLE omop_vocabulary.edge (
      concept_id_1			        INTEGER			  NOT NULL,
      concept_id_2			        INTEGER			  NOT NULL,
      relationship_id		        VARCHAR(20)	  NOT NULL,
      valid_start_date	        DATE			    NOT NULL,
      valid_end_date		        DATE			    NOT NULL,
      invalid_reason		        VARCHAR(1)		NULL,
 	    relationship_name		      VARCHAR(255)	NOT NULL,
 	    is_hierarchical		        VARCHAR(1)		NOT NULL,
      reverse_relationship_id	  VARCHAR(20)	  NOT NULL,
      reverse_relationship_name VARCHAR(255)  NOT NULL
);

INSERT INTO omop_vocabulary.edge 
SELECT 
	cr.*,
	r.relationship_name,
	r.is_hierarchical, 
	r.reverse_relationship_id, 
	rr.relationship_name AS reverse_relationship_name 
FROM omop_vocabulary.concept_relationship cr 
LEFT JOIN omop_vocabulary.relationship r 
ON cr.relationship_id = r.relationship_id 
LEFT JOIN omop_vocabulary.relationship rr 
ON r.reverse_relationship_id = rr.relationship_id
;

DROP TABLE IF EXISTS omop_vocabulary.node; 
CREATE TABLE omop_vocabulary.node AS (
SELECT 
  c.concept_id,
  c.concept_name,
  c.domain_id,
  c.vocabulary_id,
  c.concept_class_id,
  c.standard_concept,
  c.concept_code,
  c.valid_start_date,
  c.valid_end_date,
  c.invalid_reason,
  STRING_AGG(cs.concept_synonym_name, '|') AS concept_synonyms, 
  v.vocabulary_name,
  v.vocabulary_reference,
  v.vocabulary_version
FROM omop_vocabulary.CONCEPT c
LEFT JOIN omop_vocabulary.CONCEPT_SYNONYM cs 
ON c.concept_id = cs.concept_id 
LEFT JOIN omop_vocabulary.vocabulary v 
ON v.vocabulary_id = c.vocabulary_id
WHERE 
 cs.language_concept_id = 4180186 
GROUP BY 
  c.concept_id,
  c.concept_name,
  c.domain_id,
  c.vocabulary_id,
  c.concept_class_id,
  c.standard_concept,
  c.concept_code,
  c.valid_start_date,
  c.valid_end_date,
  c.invalid_reason,
  v.vocabulary_name,
  v.vocabulary_reference,
  v.vocabulary_version
)
;
```


```{r omop_vocabulary_schema1}
if (updated_settings$`Rewrite Base Tables?`) {
  
  pg13::send(
    conn_fun = "pg13::local_connect()",
    sql_statement = 
        "
        DROP TABLE IF EXISTS omop_vocabulary.edge;
        CREATE TABLE omop_vocabulary.edge (
              concept_id_1			        INTEGER			  NOT NULL,
              concept_id_2			        INTEGER			  NOT NULL,
              relationship_id		        VARCHAR(20)	  NOT NULL,
              valid_start_date	        DATE			    NOT NULL,
              valid_end_date		        DATE			    NOT NULL,
              invalid_reason		        VARCHAR(1)		NULL,
         	    relationship_name		      VARCHAR(255)	NOT NULL,
         	    is_hierarchical		        VARCHAR(1)		NOT NULL,
              reverse_relationship_id	  VARCHAR(20)	  NOT NULL,
              reverse_relationship_name VARCHAR(255)  NOT NULL
        );
        
        INSERT INTO omop_vocabulary.edge 
        SELECT 
        	cr.*,
        	r.relationship_name,
        	r.is_hierarchical, 
        	r.reverse_relationship_id, 
        	rr.relationship_name AS reverse_relationship_name 
        FROM omop_vocabulary.concept_relationship cr 
        LEFT JOIN omop_vocabulary.relationship r 
        ON cr.relationship_id = r.relationship_id 
        LEFT JOIN omop_vocabulary.relationship rr 
        ON r.reverse_relationship_id = rr.relationship_id 
        WHERE cr.concept_id_1 <> cr.concept_id_2  
        ;
        
        DROP TABLE IF EXISTS omop_vocabulary.node; 
        CREATE TABLE omop_vocabulary.node AS (
          SELECT 
            c.concept_id,
            CONCAT('https://athena.ohdsi.org/search-terms/terms/', c.concept_id) AS concept_link,
            c.concept_name,
            c.domain_id,
            c.vocabulary_id,
            c.concept_class_id,
            c.standard_concept,
            c.concept_code,
            c.valid_start_date,
            c.valid_end_date,
            c.invalid_reason,
            STRING_AGG(cs.concept_synonym_name, '|') AS concept_synonym, 
            v.vocabulary_name,
            v.vocabulary_reference,
            v.vocabulary_version
          FROM omop_vocabulary.CONCEPT c
          LEFT JOIN omop_vocabulary.CONCEPT_SYNONYM cs 
          ON c.concept_id = cs.concept_id 
          LEFT JOIN omop_vocabulary.vocabulary v 
          ON v.vocabulary_id = c.vocabulary_id
          WHERE 
           cs.language_concept_id = 4180186 
          GROUP BY 
            c.concept_id,
            c.concept_name,
            c.domain_id,
            c.vocabulary_id,
            c.concept_class_id,
            c.standard_concept,
            c.concept_code,
            c.valid_start_date,
            c.valid_end_date,
            c.invalid_reason,
            v.vocabulary_name,
            v.vocabulary_reference,
            v.vocabulary_version
        )
        ;
        ")
}
```


## OMOP Neo4j Schema   

### Preprocessing Edge Header and Edge Tables    

If the OMOP Neo4j schema is written for the first time ever, 
the Preprocessing Edge Header and Preprocessing Edge tables 
are written. Otherwise, the both tables are rewritten if a 
new OMOP Version is detected.  

```sql
DROP TABLE IF EXISTS omop_neo4j.pre_edge_header;
CREATE TABLE omop_neo4j.pre_edge_header AS (
SELECT 
  concept_id_1    AS start_id_col, 
  concept_id_2    AS end_id_col,
  relationship_id AS type_col,
  e.*
FROM omop_vocabulary.edge e
LIMIT 5
);

DROP TABLE IF EXISTS omop_neo4j.pre_edge;
CREATE TABLE omop_neo4j.pre_edge AS (
SELECT
  concept_id_1    AS start_id_col, 
  concept_id_2    AS end_id_col,
  relationship_id AS type_col,
  e.*
FROM omop_vocabulary.edge e
);
``` 

```{r omop_neo4j_schema1}
conn <- pg13::local_connect()
if (!pg13::schema_exists(conn = conn, 
                         schema = "omop_neo4j")) {
  
  pg13::create_schema(conn = conn, 
                      schema = "omop_neo4j")  
  
  pg13::send(conn_fun = "pg13::local_connect()",
             sql_statement = 
                "
                DROP TABLE IF EXISTS omop_neo4j.pre_edge_header;
                CREATE TABLE omop_neo4j.pre_edge_header AS (
                SELECT 
                  concept_id_1    AS start_id_col, 
                  concept_id_2    AS end_id_col,
                  relationship_id AS type_col,
                  e.*
                FROM omop_vocabulary.edge e
                LIMIT 5
                );
                
                DROP TABLE IF EXISTS omop_neo4j.pre_edge;
                CREATE TABLE omop_neo4j.pre_edge AS (
                SELECT
                  concept_id_1    AS start_id_col, 
                  concept_id_2    AS end_id_col,
                  relationship_id AS type_col,
                  e.*
                FROM omop_vocabulary.edge e
                );
                "
               )
  omop_neo4j_schema1_dt <- as.character(Sys.time())
  
} else {
  
  if (updated_settings$`Rewrite Node and Edge Tables?`) {
      pg13::send(conn_fun = "pg13::local_connect()",
                 sql_statement = 
                    "
                    DROP TABLE IF EXISTS omop_neo4j.pre_edge_header;
                    CREATE TABLE omop_neo4j.pre_edge_header AS (
                    SELECT 
                      concept_id_1    AS start_id_col, 
                      concept_id_2    AS end_id_col,
                      relationship_id AS type_col,
                      e.*
                    FROM omop_vocabulary.edge e
                    LIMIT 5
                    );
                    
                    DROP TABLE IF EXISTS omop_neo4j.pre_edge;
                    CREATE TABLE omop_neo4j.pre_edge AS (
                    SELECT
                      concept_id_1    AS start_id_col, 
                      concept_id_2    AS end_id_col,
                      relationship_id AS type_col,
                      e.*
                    FROM omop_vocabulary.edge e
                    );
                    "
                   )
  }
}
pg13::dc(conn = conn)
```


### Preprocessing Node Header and Node Tables    

These tables are rewritten with any new combination of 
name_col, label_col, and id_col as well as a new OMOP Version.  


```sql
DROP TABLE IF EXISTS omop_neo4j.pre_node_header;
CREATE TABLE omop_neo4j.pre_node_header AS (
  SELECT 
    @label_col AS label_col,
    @id_col    AS id_col, 
    @name_col  AS name_col, 
    n.*
  FROM omop_vocabulary.node n 
  LIMIT 5
);

DROP TABLE IF EXISTS omop_neo4j.pre_node;
CREATE TABLE omop_neo4j.pre_node AS (
  SELECT 
    @label_col AS label_col,
    @id_col    AS id_col, 
    @name_col  AS name_col, 
    n.*
  FROM omop_vocabulary.node n
);"
```

```{r omop_neo4j_schema2}
if (updated_settings$`Rewrite Node and Edge Tables?`) {
  
  pg13::send(
    conn_fun = "pg13::local_connect()",
    sql_statement = 
      SqlRender::render(
        "
        DROP TABLE IF EXISTS omop_neo4j.pre_node_header;
        CREATE TABLE omop_neo4j.pre_node_header AS (
          SELECT 
            @label_col AS label_col,
            @id_col    AS id_col, 
            @name_col  AS name_col, 
            n.*
          FROM omop_vocabulary.node n 
          LIMIT 5
        );
        
        DROP TABLE IF EXISTS omop_neo4j.pre_node;
        CREATE TABLE omop_neo4j.pre_node AS (
          SELECT 
            @label_col AS label_col,
            @id_col    AS id_col, 
            @name_col  AS name_col, 
            n.*
          FROM omop_vocabulary.node n
        );", 
          label_col     = params$label_col,
          id_col        = params$id_col,
          name_col      = params$name_col))
  
}
```

  
# Processing  

## Node Header  

The first 5 rows of the Node table is exported to a temp csv 
file.  

```{r}
if (updated_settings$`Rewrite Node and Edge CSVS?`) {
  nodes_tmp_csv1 <- tempfile(fileext = ".csv")
  pg13::send(
    conn_fun = "pg13::local_connect()",
    sql_statement = 
      SqlRender::render(
        "
        COPY omop_neo4j.pre_node_header TO '@nodes_tmp_csv' WITH DELIMITER ',' CSV HEADER QUOTE E'\\b';", 
          nodes_tmp_csv = nodes_tmp_csv1)
  )
}
```

The temp csv is moved to a preprocessed _node_header.csv_ file.  

```{r}
pre_node_header_file <- file.path(pre_data_folder, "node_header.csv")
if (updated_settings$`Rewrite Node and Edge CSVS?`) {
  if (file.exists(pre_node_header_file)) { file.remove(pre_node_header_file)}
  file.copy(from = nodes_tmp_csv1,
            to   = pre_node_header_file)
  unlink(nodes_tmp_csv1)
}
```

The node header is processed by adding the `:LABEL`, `:ID`, 
and `name` markers the `r print(params$label_col)`, 
`r print(params$id_col)`, and `r print(params$name_col)` 
header fields, respectively.     

```{r}
if (updated_settings$`Rewrite Node and Edge CSVS?`) {
  node_header <- 
    read_csv(file = pre_node_header_file,
             col_names = TRUE,
             col_types = readr::cols(.default = "c"),
             n_max = 1L) %>%
    rename_at(vars(all_of("label_col")), ~str_replace(.,
                                                      "label_col", 
                                                      paste0(params$label_col, ":LABEL"))) %>%
    rename_at(vars(all_of("id_col")), ~str_replace(.,
                                                      "id_col", 
                                                      paste0(params$id_col, ":ID"))) %>%  
    rename_at(vars(all_of("name_col")), ~str_replace(.,
                                                      "name_col", 
                                                      "name")) %>%
    rename_at(vars(concept_synonym), ~str_replace(.,
                                                  "concept_synonym",
                                                  "concept_synonym:string[]"))
}
```

The field names are isolated and the final header file is written 
to the final folder.  

```{r}
node_header_file <- file.path(final_folder, "node_header.csv")
if (updated_settings$`Rewrite Node and Edge CSVS?`) {
  node_header      <- node_header[-(1:nrow(node_header)),]
  if (file.exists(node_header_file)) {file.remove(node_header_file)}
  write_csv(x         = node_header,
            file      = node_header_file,
            col_names = TRUE)
}
```

### Results    

```{r}
kableExtra::kbl(
  tibble(
    pre = 
      read_csv(file = pre_node_header_file,
               col_names = TRUE,
               col_types = readr::cols(.default = "c"),
               n_max = 1L) %>%
      colnames(),
    post = 
      read_csv(file = node_header_file,
               col_names = TRUE,
               col_types = readr::cols(.default = "c"),
               n_max = 1L) %>%
      colnames()),
  align = c("l", "l")) %>% 
  kableExtra::kable_styling(
           full_width = FALSE,
           position = "left",
           htmltable_class = "lightable-minimal")
```


## Node Data  

```{r}
pre_node_file <- file.path(pre_data_folder, "node.csv")
node_file <- file.path(final_folder, "node.csv")
if (updated_settings$`Rewrite Node and Edge CSVS?`) {
  nodes_tmp_csv2 <- tempfile(fileext = ".csv")
  pg13::send(
    conn_fun = "pg13::local_connect()",
    sql_statement = 
      SqlRender::render(
        "
        COPY omop_neo4j.pre_node TO '@nodes_tmp_csv' WITH DELIMITER ',' CSV HEADER FORCE QUOTE vocabulary_name;", 
          nodes_tmp_csv = nodes_tmp_csv2)
  )
  
  if (file.exists(pre_node_file)) { file.remove(pre_node_file)}
  file.copy(from = nodes_tmp_csv2,
            to   = pre_node_file)
  unlink(nodes_tmp_csv2)
  
  if (file.exists(node_file)) { file.remove(node_file)}
  system(
    sprintf("sed 1d %s > %s", 
              glitter::formatCli(pre_node_file),
              glitter::formatCli(node_file))
    )
}
```

### Results  

The first 5 lines of the file:  

```{r}
read_lines(node_file,
         n_max = 5)
```

## Edge Header  

```{r}
pre_edge_header_file <- file.path(pre_data_folder, "edge_header.csv")
if (updated_settings$`Rewrite Node and Edge CSVS?`) {
  edges_tmp_csv1 <- tempfile(fileext = ".csv")
  pg13::send(
    conn_fun = "pg13::local_connect()",
    sql_statement = 
      SqlRender::render(
        "
        COPY omop_neo4j.pre_edge_header TO '@edges_tmp_csv' WITH DELIMITER ',' CSV HEADER QUOTE E'\\b'; 
        ", 
         edges_tmp_csv = edges_tmp_csv1)
  )
  
  if (file.exists(pre_edge_header_file)) {file.remove(pre_edge_header_file)}
  file.copy(from = edges_tmp_csv1,
            to   = pre_edge_header_file)
  unlink(edges_tmp_csv1)
}
```

```{r}
edge_header_file <- file.path(final_folder, "edge_header.csv")
if (updated_settings$`Rewrite Node and Edge CSVS?`) {
  edge_header <- 
    read_csv(file = pre_edge_header_file,
             col_names = TRUE,
             col_types = readr::cols(.default = "c"),
             n_max = 1L) %>%
    rename(`concept_id_1:START_ID` = start_id_col, 
           `concept_id_2:END_ID`   = end_id_col,
           `relationship_id:TYPE`  = type_col) %>%
    select(`concept_id_1:START_ID`,
           `concept_id_2:END_ID`,
           `relationship_id:TYPE`,
           everything())
  
  edge_header <- 
    edge_header[-(1:nrow(edge_header)),]
  
  if (file.exists(edge_header_file)) {file.remove(edge_header_file)}
  write_csv(x         = edge_header,
            file      = edge_header_file,
            col_names = TRUE)
}
```

### Results    

```{r}
kableExtra::kbl(
  tibble(
    pre = 
      read_csv(file = pre_edge_header_file,
               col_names = TRUE,
               col_types = readr::cols(.default = "c"),
               n_max = 1L) %>%
      colnames()
      ),
    post = 
      read_csv(file = edge_header_file,
               col_names = TRUE,
               col_types = readr::cols(.default = "c"),
               n_max = 1L) %>%
      colnames(),
  align = c("l", "l")) %>% 
  kableExtra::kable_styling(
           full_width = FALSE,
           position = "left",
           htmltable_class = "lightable-minimal")
```


## Edge Data  

```{r}
pre_edge_file <- file.path(pre_data_folder, "edge.csv")
edge_file <- file.path(final_folder, "edge.csv")

if (updated_settings$`Rewrite Node and Edge CSVS?`) {
  edges_tmp_csv2 <- tempfile(fileext = ".csv")
  pg13::send(
    conn_fun = "pg13::local_connect()",
    sql_statement = 
      SqlRender::render(
        "
        COPY omop_neo4j.pre_edge TO '@edges_tmp_csv' WITH DELIMITER ',' CSV HEADER QUOTE E'\\b';", 
          edges_tmp_csv = edges_tmp_csv2)
  )
  
  if (file.exists(pre_edge_file)) { file.remove(pre_edge_file)}
  file.copy(from = edges_tmp_csv2,
            to   = pre_edge_file)
  unlink(edges_tmp_csv2)
  
  
  if (file.exists(edge_file)) { file.remove(edge_file)}
  system(
    sprintf("sed 1d %s > %s", 
              glitter::formatCli(pre_edge_file),
              glitter::formatCli(edge_file))
    )
}
```

### Results  

The first 5 lines of the file:  

```{r}
read_lines(edge_file,
         n_max = 5)
```


# Setup Neo4j   

## Populate the Import Folder  

The csvs are copied to the import folder.  

```{r}
final_files <- 
  file.path(final_folder, 
            c("edge_header.csv",
              "edge.csv",
              "node_header.csv",
              "node.csv"))

if (updated_settings$`Import to Neo4j Import Folder?`) {
  unlink(import_folder,
         recursive = TRUE)
  dir.create(import_folder)
  
  
  import_files <- vector()
  for (final_file in final_files) {
   
    import_file <- 
      file.path(import_folder,
                basename(final_file))
    if (file.exists(import_file)) {file.remove(import_file)}
    
    file.copy(from = final_file,
              to   = import_file)
    
    import_files <- 
      c(import_files,
        import_file)
     
  }
  
} else {
  
  import_files <- 
    file.path(import_folder, 
            c("edge_header.csv",
              "edge.csv",
              "node_header.csv",
              "node.csv"))
  
}
```

### Results  

```{r}
left_join(
  final_files %>% 
    file.info() %>%
    rownames_to_column("file_path") %>% 
    transmute(file_path,
              file = basename(file_path),
              final_size = size/(10^9)) %>%
    mutate(final_md5sum = tools::md5sum(file_path)) %>%
    select(-file_path),
  import_files %>% 
    file.info() %>%
    rownames_to_column("file_path") %>% 
    transmute(file_path,
              file = basename(file_path),
              import_size = size/(10^9)) %>%
    mutate(import_md5sum = tools::md5sum(file_path)) %>%
    select(-file_path),
  by = "file"
)
```

```{r}
unlink(pre_data_folder,
       recursive = TRUE)
```


## Add README  

```{r,echo=FALSE,results='asis'}
README_file <- file.path(final_folder, "README")  

cat(
        "OMOP Vocabularies",
sprintf("%s Version %s", omop_version, version),    
sprintf("Created On: %s", as.character(Sys.time())), 
        "---",
        "1. Create a new database in Neo4j Desktop.", 
        "2. Copy the `node_header.csv`, `node.csv`, `edge_header.csv`, and `edge.csv` files to the Import folder.", 
        "3. Copy load.sh to the folder above the Import folder, which is the root folder for the database.",
        "4. cd into the same folder as above from the command line.",
        "5. Run `sudo chmod +x load.sh`.",
        "6. Run `./load.sh` which will load the data into Neo4j.",
          append = FALSE, 
          file   = README_file,
          sep    = "  \n"
    )


cat(
  "```",
  read_lines(README_file),
  "```",
  sep = "\n")
```


## Shell Script


A shell script to load the data into Neo4j is written locally 
to the final folder and copied to the root `r print(params$neo4j_db)` 
folder.  


```{r}
  load_shell <- 
      c("bin/neo4j-admin import --database neo4j",
        "--array-delimiter='|' --delimiter=','",
        "--nodes import/node_header.csv,import/node.csv",
        "--relationships import/edge_header.csv,import/edge.csv",
        "--skip-bad-relationships")
  
  load_shell <- 
    paste(load_shell,
          collapse = " ")
  
  
  local_shell_file <- 
    file.path(final_folder, 
                       "load.sh")
  
  cat(
    load_shell,
    file = local_shell_file, 
    append = FALSE)
    
   dbmss_load_shell_file <- 
     file.path(params$dbmss_path, 
                       params$neo4j_db, 
                       "load.sh")
 if (file.exists(dbmss_load_shell_file)) {file.remove(dbmss_load_shell_file)}
   
  file.copy(from = local_shell_file,
            to   = dbmss_load_shell_file)
```


## Zip Data  

```{r,echo=FALSE,results='asis'}
#if (params$zip_import_files) {
  zip_file <- file.path(outgoing_folder, 
                      sprintf("OMOP Vocabularies %s Version %s.zip", 
                                omop_version,
                                version))
  
  command <- 
    sprintf("cd\ncd %s\nzip -r %s ./*",
              glitter::formatCli(final_folder),
              glitter::formatCli(zip_file))
  
  system(
    command = command
  )
  
  unlink(final_folder,
         recursive = TRUE)
#}

cat("```",
    command,
    "```",
    sep = "\n")
```


# Run Shell Script  

```{r}
if (updated_settings$`Load Data into Neo4j?`) {
  root_dir <- glitter::formatCli(file.path(params$dbmss_path, params$neo4j_db))
  system(command = 
           sprintf('cd\ncd %s\necho "%s" | sudo -S -k chmod +x load.sh\n.\\/load.sh', 
                   root_dir,
                   Sys.getenv("pw"))
           )
}
```


